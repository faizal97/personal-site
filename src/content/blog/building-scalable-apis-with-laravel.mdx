---
title: "Building Scalable REST APIs with Laravel"
description: "Practical patterns for designing maintainable, high-performance APIs in Laravel — from route organization to caching strategies."
pubDate: 2024-08-15
tags: ["laravel", "php", "api", "backend"]
---

After building dozens of APIs across enterprise travel platforms and government systems, I've distilled the patterns that consistently lead to maintainable, performant codebases.

## Route Organization

Group your API routes by domain, not by HTTP method. This keeps related logic together and makes it easy to apply middleware per resource:

```php
Route::prefix('v1')->group(function () {
    Route::apiResource('bookings', BookingController::class);
    Route::apiResource('travelers', TravelerController::class);

    Route::prefix('bookings/{booking}')->group(function () {
        Route::post('confirm', [BookingController::class, 'confirm']);
        Route::post('cancel', [BookingController::class, 'cancel']);
    });
});
```

## Request Validation

Always use Form Requests. They separate validation logic from controllers and make rules testable in isolation:

```php
class StoreBookingRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'traveler_id' => ['required', 'exists:travelers,id'],
            'destination' => ['required', 'string', 'max:255'],
            'check_in' => ['required', 'date', 'after:today'],
            'check_out' => ['required', 'date', 'after:check_in'],
            'currency' => ['required', 'string', 'size:3'],
        ];
    }
}
```

## API Resources for Response Shaping

Never return Eloquent models directly. API Resources give you a stable contract that won't break when your database schema changes:

```php
class BookingResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'status' => $this->status,
            'destination' => $this->destination,
            'dates' => [
                'check_in' => $this->check_in->toIso8601String(),
                'check_out' => $this->check_out->toIso8601String(),
            ],
            'traveler' => new TravelerResource($this->whenLoaded('traveler')),
            'total' => [
                'amount' => $this->total_amount,
                'currency' => $this->currency,
            ],
        ];
    }
}
```

## Caching Strategy

For read-heavy endpoints, cache at the query level with tagged caches so you can invalidate granularly:

```php
public function index(Request $request): JsonResponse
{
    $bookings = Cache::tags(['bookings', "user:{$request->user()->id}"])
        ->remember("bookings:list:{$request->query('page', 1)}", 3600, function () use ($request) {
            return Booking::query()
                ->where('user_id', $request->user()->id)
                ->with('traveler')
                ->paginate(20);
        });

    return BookingResource::collection($bookings)->response();
}
```

Invalidate on write:

```php
public function store(StoreBookingRequest $request): JsonResponse
{
    $booking = Booking::create($request->validated());

    Cache::tags(['bookings', "user:{$request->user()->id}"])->flush();

    return (new BookingResource($booking))
        ->response()
        ->setStatusCode(201);
}
```

## Rate Limiting

Apply rate limits per endpoint sensitivity. Authentication endpoints need stricter limits:

```php
RateLimiter::for('api', function (Request $request) {
    return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});

RateLimiter::for('auth', function (Request $request) {
    return Limit::perMinute(5)->by($request->ip());
});
```

## Key Takeaways

1. **Organize by domain** — group routes, controllers, and requests by business concept
2. **Validate early** — Form Requests catch bad data before it reaches your logic
3. **Shape responses explicitly** — API Resources are your public contract
4. **Cache strategically** — tagged caches give you surgical invalidation
5. **Rate limit by sensitivity** — not all endpoints need the same limits

These patterns have served me well across projects handling thousands of daily API calls. The investment in structure pays dividends when requirements inevitably change.
