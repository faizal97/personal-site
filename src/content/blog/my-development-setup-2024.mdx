---
title: "My Development Setup in 2024"
description: "The tools, workflows, and configurations I use daily for backend development — from terminal to deployment."
pubDate: 2024-06-20
tags: ["tooling", "workflow", "productivity"]
---

I spend most of my time in the terminal and my editor. Over the years I've refined a setup that minimizes friction between thinking and shipping.

## Editor: VS Code + Vim Keybindings

I use VS Code with the Vim extension. The combination gives me modal editing speed with VS Code's ecosystem of extensions:

```json
{
  "vim.leader": "<space>",
  "vim.normalModeKeyBindingsNonRecursive": [
    { "before": ["<leader>", "w"], "commands": [":w"] },
    { "before": ["<leader>", "f"], "commands": ["workbench.action.quickOpen"] },
    { "before": ["<leader>", "g"], "commands": ["workbench.action.findInFiles"] }
  ]
}
```

Key extensions I can't work without:
- **PHP Intelephense** — intelligent autocompletion and refactoring for PHP
- **Laravel Extra Intellisense** — route names, config keys, view completions
- **GitLens** — inline blame and history navigation
- **REST Client** — test API endpoints without leaving the editor

## Terminal: Warp + Starship

My terminal is [Warp](https://www.warp.dev/) with the Starship prompt. Starship shows me the git branch, PHP version, and Node version at a glance:

```toml
# ~/.config/starship.toml
[character]
success_symbol = "[➜](bold green)"

[git_branch]
symbol = " "
style = "bold purple"

[php]
symbol = " "
format = "[$symbol$version]($style) "

[nodejs]
symbol = " "
format = "[$symbol$version]($style) "
```

## Database: TablePlus + CLI

For visual database work I use TablePlus. It handles MySQL, PostgreSQL, and Redis connections with a clean interface. For quick queries and migrations, I stay in the terminal:

```bash
# Quick database inspection
php artisan tinker --execute="DB::table('bookings')->where('status', 'pending')->count()"

# Run specific migration
php artisan migrate --path=database/migrations/2024_01_15_create_invoices_table.php

# Fresh seed for development
php artisan migrate:fresh --seed
```

## API Testing: Postman Collections

I organize Postman collections by feature and environment. Each collection has pre-request scripts that handle authentication automatically:

```javascript
// Pre-request script for authenticated endpoints
const loginResponse = pm.sendRequest({
    url: pm.environment.get('base_url') + '/api/v1/auth/login',
    method: 'POST',
    header: { 'Content-Type': 'application/json' },
    body: {
        mode: 'raw',
        raw: JSON.stringify({
            email: pm.environment.get('test_email'),
            password: pm.environment.get('test_password')
        })
    }
});

pm.environment.set('auth_token', loginResponse.json().data.token);
```

## Docker for Local Development

Every project gets a `docker-compose.yml` that mirrors production. No more "works on my machine":

```yaml
services:
  app:
    build: .
    volumes:
      - .:/var/www/html
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: app
      MYSQL_ROOT_PASSWORD: secret
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
```

## Git Workflow

I follow a simple branching model: `main` is always deployable, feature branches are short-lived, and every PR gets a review:

```bash
# Start feature
git checkout -b feature/booking-cancellation

# Commit with conventional format
git commit -m "feat(bookings): add cancellation with refund calculation"

# Push and create PR
git push -u origin feature/booking-cancellation
gh pr create --fill
```

## Deployment: CI/CD Pipeline

GitHub Actions handles testing and deployment. Every push runs the test suite, and merges to `main` trigger deployment:

```yaml
- name: Run Tests
  run: |
    php artisan config:clear
    php artisan test --parallel
  env:
    DB_CONNECTION: mysql
    DB_HOST: 127.0.0.1
    DB_DATABASE: testing
```

## The Philosophy

My setup optimizes for three things:
1. **Fast feedback loops** — tests run in seconds, not minutes
2. **Reproducibility** — Docker means the same environment everywhere
3. **Keyboard-driven** — mouse usage is the exception, not the rule

The best tool is the one you've internalized deeply enough that it disappears. I'd rather master a small set of tools than dabble in many.
